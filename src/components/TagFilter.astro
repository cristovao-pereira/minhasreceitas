---
interface Props {
	tags: string[];
}

const { tags } = Astro.props;
---

<div class="controls-container">
	<label class="toggle-switch">
		<input type="checkbox" id="multi-select-toggle" checked>
		<span class="slider"></span>
		<span class="label-text">Seleção Múltipla</span>
	</label>
</div>

<div class="tag-filter-container">
	<button class="filter-btn active" data-tag="all">Todas</button>
	{tags.map(tag => (
		<button class="filter-btn" data-tag={tag}>{tag}</button>
	))}
</div>

<div class="empty-state" style="display: none;">
	<p>Nenhuma receita encontrada com os filtros selecionados.</p>
	<button id="clear-filters-btn">Limpar Filtros</button>
</div>

<script>
	const buttons = document.querySelectorAll('.filter-btn');
	const cards = document.querySelectorAll('.recipe-card');
	const emptyState = document.querySelector('.empty-state') as HTMLElement;
	const clearBtn = document.getElementById('clear-filters-btn');
	const multiSelectToggle = document.getElementById('multi-select-toggle') as HTMLInputElement;

	function updateFilters() {
		const activeTags : string[] = [];
		buttons.forEach(btn => {
			if (btn.classList.contains('active') && btn.getAttribute('data-tag') !== 'all') {
				activeTags.push(btn.getAttribute('data-tag')!);
			}
		});

		let visibleCount = 0;

		cards.forEach(card => {
			const cardTags = card.getAttribute('data-tags')?.split(',') || [];
			// Logic: If activeTags is empty -> Show All. Else -> Show partial (OR logic)
			const shouldShow = activeTags.length === 0 || cardTags.some(tag => activeTags.includes(tag));

			if (shouldShow) {
				(card as HTMLElement).style.display = 'flex';
				visibleCount++;
			} else {
				(card as HTMLElement).style.display = 'none';
			}
		});

		if (visibleCount === 0) {
			emptyState.style.display = 'flex';
		} else {
			emptyState.style.display = 'none';
		}
	}

	buttons.forEach(btn => {
		btn.addEventListener('click', () => {
			const tag = btn.getAttribute('data-tag');
			const isMultiple = multiSelectToggle.checked;

			if (tag === 'all') {
				buttons.forEach(b => b.classList.remove('active'));
				btn.classList.add('active');
			} else {
				if (!isMultiple) {
					// Single mode: clear all others first
					buttons.forEach(b => b.classList.remove('active'));
					btn.classList.add('active'); 
				} else {
					// Multiple mode: toggle current
					btn.classList.toggle('active');
					
					// If toggling off leaves no active tags, select 'all'
					// But wait, we need to check if we just turned on the "all" button implicitly?
					// No, if I uncheck the last tag, I should probably check "all".
				}
				
				// Handle "All" button state for both modes
				const allBtn = document.querySelector('.filter-btn[data-tag="all"]');
				if (allBtn) {
					if (!isMultiple) {
						// In single mode, if I clicked a specific tag, 'all' is already removed by the loop above.
						allBtn.classList.remove('active'); 
					} else {
						// In multi mode
						allBtn.classList.remove('active');
					}
				}

				// Check if we ended up with NO active buttons
				const anyActive = Array.from(buttons).some(b => b.classList.contains('active') && b.getAttribute('data-tag') !== 'all');
				if (!anyActive && allBtn) {
					allBtn.classList.add('active');
				}
			}

			updateFilters();
		});
	});

	// Handle switch change
	multiSelectToggle.addEventListener('change', () => {
		if (!multiSelectToggle.checked) {
			// Switched to single mode: keep only the first active tag found (or All)
			let foundActive = false;
			buttons.forEach(btn => {
				if (btn.getAttribute('data-tag') !== 'all' && btn.classList.contains('active')) {
					if (foundActive) {
						btn.classList.remove('active'); // Remove subsequent selections
					} else {
						foundActive = true;
					}
				}
			});
			updateFilters();
		}
	});

	clearBtn?.addEventListener('click', () => {
		const allBtn = document.querySelector('.filter-btn[data-tag="all"]') as HTMLElement;
		if(allBtn) allBtn.click();
	});
</script>

<style>
	.tag-filter-container {
		display: flex;
		flex-wrap: wrap;
		gap: 0.75rem;
		justify-content: center;
		margin-bottom: 2rem;
	}

	.filter-btn {
		background: transparent;
		border: 1px solid var(--seara-orange);
		color: var(--seara-orange);
		padding: 0.5rem 1.25rem;
		border-radius: 2rem;
		font-family: 'Outfit', sans-serif;
		font-weight: 500;
		cursor: pointer;
		transition: all 0.2s ease;
		font-size: 0.9rem;
	}

	.filter-btn:hover {
		background: rgba(240, 78, 35, 0.1);
	}

	.filter-btn.active {
		background: var(--seara-orange);
		color: white;
		box-shadow: 0 4px 6px -1px rgba(240, 78, 35, 0.3);
	}

	.empty-state {
		flex-direction: column;
		align-items: center;
		padding: 3rem;
		gap: 1rem;
		color: var(--text-muted);
		text-align: center;
	}

	.empty-state button {
		background: transparent;
		border: 1px solid var(--seara-orange);
		color: var(--seara-orange);
		padding: 0.5rem 1rem;
		border-radius: 4px;
		cursor: pointer;
	}

	.controls-container {
		display: flex;
		justify-content: center;
		margin-bottom: 1rem;
	}

	.toggle-switch {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		cursor: pointer;
		font-size: 0.9rem;
		user-select: none;
	}

	.toggle-switch input {
		display: none;
	}

	.toggle-switch .slider {
		display: inline-block;
		width: 36px;
		height: 20px;
		background-color: #ccc;
		border-radius: 20px;
		position: relative;
		transition: 0.3s;
	}

	.toggle-switch .slider::before {
		content: "";
		position: absolute;
		height: 16px;
		width: 16px;
		left: 2px;
		bottom: 2px;
		background-color: white;
		border-radius: 50%;
		transition: 0.3s;
	}

	.toggle-switch input:checked + .slider {
		background-color: var(--seara-orange);
	}

	.toggle-switch input:checked + .slider::before {
		transform: translateX(16px);
	}
</style>
